#!/usr/bin/env python3
# -*- coding: utf-8 -*-
r"""
agent_refine.py â€” Deterministic agent-style refinements for examx TeX

Features:
- Replace inline TikZ placeholders (from ocr_to_examx) with \input figures/tikz/figNN.tikz
- Create missing TikZ template files alongside the output TeX
- Optionally apply a deterministic JSON/YAML "edit plan" (future extension)

Usage:
  python3 tools/agent_refine.py input.tex output.tex --create-tikz
  python3 tools/agent_refine.py input.tex output.tex --plan plan.json
"""

import argparse
import json
import re
from pathlib import Path
from typing import List, Optional, Tuple

try:
    import yaml  # optional
except Exception:
    yaml = None


TIKZ_BLOCK_PATTERN = re.compile(
    r"\\begin\{center\}\s*\n\\begin\{tikzpicture\}[\\s\\S]*?% IMAGE_TODO: (?P<path>[^\n]+)[\\s\\S]*?\\end\{tikzpicture\}\s*\n\\end\{center\}",
    re.MULTILINE,
)


def load_plan(plan_path: Optional[Path]):
    if not plan_path:
        return None
    text = plan_path.read_text(encoding="utf-8")
    try:
        return json.loads(text)
    except Exception:
        if yaml is None:
            raise
        return yaml.safe_load(text)


def ensure_tikz_dir(out_tex: Path) -> Path:
    tikz_dir = out_tex.parent / "figures" / "tikz"
    tikz_dir.mkdir(parents=True, exist_ok=True)
    return tikz_dir


def next_fig_id(tikz_dir: Path) -> int:
    max_id = 0
    for p in tikz_dir.glob("fig*.tikz"):
        m = re.match(r"fig(\d+)\.tikz$", p.name)
        if m:
            max_id = max(max_id, int(m.group(1)))
    return max_id + 1


def create_tikz_template(tikz_file: Path, source_hint: str):
    content = (
        "% Auto-generated by agent_refine.py\n"
        f"% SOURCE: {source_hint}\n"
        "% TODO: Replace with actual TikZ code derived from the image.\n"
        "\\begin{tikzpicture}[scale=1.05,>=Stealth,line cap=round,line join=round]\n"
        "  % ...\n"
        "\\end{tikzpicture}\n"
    )
    tikz_file.write_text(content, encoding="utf-8")


def replace_tikz_blocks(tex: str, out_tex: Path, create_tikz: bool) -> Tuple[str, List[Path]]:
    r"""Replace inline tikzpicture blocks with \input{figures/tikz/figNN.tikz}."""
    tikz_dir = ensure_tikz_dir(out_tex)
    created: List[Path] = []

    def repl(match):
        nonlocal created
        src_path = match.group("path").strip()
        if create_tikz:
            fig_id = next_fig_id(tikz_dir)
            tikz_file = tikz_dir / f"fig{fig_id:02d}.tikz"
            create_tikz_template(tikz_file, src_path)
            created.append(tikz_file)
            return ("\\begin{center}\n"
                    f"\\input{{figures/tikz/{tikz_file.name}}}\n"
                    "\\end{center}")
        # If not creating files, keep original block
        return match.group(0)

    new_tex = TIKZ_BLOCK_PATTERN.sub(repl, tex)
    return new_tex, created


def apply_plan(tex: str, plan: Optional[dict]) -> str:
    """Apply a deterministic edit plan (simple search/replace list)."""
    if not plan:
        return tex
    for edit in plan.get("edits", []):
        pattern = edit.get("pattern")
        replace = edit.get("replace", "")
        flags = re.MULTILINE | re.DOTALL if edit.get("dotall") else re.MULTILINE
        if pattern is None:
            continue
        tex = re.sub(pattern, replace, tex, flags=flags)
    return tex


def remove_consecutive_duplicate_lines(tex: str, min_length: int = 20) -> str:
    r"""ğŸ†• v1.0.1ï¼šç§»é™¤è¿ç»­é‡å¤çš„è¡Œï¼ˆä¿å®ˆç­–ç•¥ï¼‰
    
    é—®é¢˜åœºæ™¯ï¼š
    OCR æˆ– Pandoc è½¬æ¢æœ‰æ—¶ä¼šäº§ç”Ÿè¿ç»­çš„é‡å¤è¡Œï¼Œä¾‹å¦‚ï¼š
      æ‰€ä»¥\(a_{n} = 2 \times 4^{n - 1}\)ï¼›
      æ‰€ä»¥\(a_{n} = 2 \times 4^{n - 1}\)ï¼›
    
    ä¿å®ˆç­–ç•¥ï¼š
    1. åªç§»é™¤å®Œå…¨ç›¸åŒçš„è¿ç»­è¡Œ
    2. è¡Œé•¿åº¦å¿…é¡»å¤§äº min_lengthï¼ˆé¿å…è¯¯åˆ çŸ­è¡Œå¦‚ "\par"ï¼‰
    3. ä¿ç•™ç¬¬ä¸€è¡Œï¼Œç§»é™¤åç»­é‡å¤è¡Œ
    4. ä¸å¤„ç†ç©ºè¡Œå’Œåªæœ‰ç©ºç™½çš„è¡Œ
    
    Args:
        tex: è¾“å…¥çš„ LaTeX æ–‡æœ¬
        min_length: æœ€å°è¡Œé•¿åº¦é˜ˆå€¼ï¼ŒçŸ­äºæ­¤é•¿åº¦çš„è¡Œä¸æ£€æµ‹
        
    Returns:
        å»é™¤é‡å¤è¡Œåçš„æ–‡æœ¬
    """
    if not tex:
        return tex
    
    lines = tex.split('\n')
    result = []
    prev_line = None
    removed_count = 0
    
    for line in lines:
        stripped = line.strip()
        
        # ç©ºè¡Œæˆ–åªæœ‰ç©ºç™½çš„è¡Œï¼šç›´æ¥ä¿ç•™
        if not stripped:
            result.append(line)
            prev_line = None  # é‡ç½®ï¼Œç©ºè¡Œä¸å‚ä¸é‡å¤æ£€æµ‹
            continue
        
        # å¤ªçŸ­çš„è¡Œï¼šç›´æ¥ä¿ç•™ï¼ˆå¦‚ \par, \end{...} ç­‰ï¼‰
        if len(stripped) < min_length:
            result.append(line)
            prev_line = stripped
            continue
        
        # æ£€æŸ¥æ˜¯å¦ä¸ä¸Šä¸€è¡Œå®Œå…¨ç›¸åŒ
        if prev_line and stripped == prev_line:
            # é‡å¤è¡Œï¼Œè·³è¿‡
            removed_count += 1
            continue
        
        # éé‡å¤è¡Œï¼Œä¿ç•™
        result.append(line)
        prev_line = stripped
    
    if removed_count > 0:
        print(f"  âœ… ç§»é™¤äº† {removed_count} è¡Œé‡å¤å†…å®¹")
    
    return '\n'.join(result)


def main():
    ap = argparse.ArgumentParser(description="Agent-style deterministic refine for examx TeX")
    ap.add_argument("input", help="Input .tex from ocr_to_examx")
    ap.add_argument("output", help="Output .tex after refinement")
    ap.add_argument("--plan", help="JSON/YAML edit plan file", default=None)
    ap.add_argument("--create-tikz", help="Create tikz files and replace placeholders", action="store_true")
    ap.add_argument("--no-dedup", help="Skip duplicate line removal", action="store_true")
    args = ap.parse_args()

    in_tex = Path(args.input)
    out_tex = Path(args.output)
    out_tex.parent.mkdir(parents=True, exist_ok=True)

    tex = in_tex.read_text(encoding="utf-8")

    # Optionally create tikz inputs
    tex, created = replace_tikz_blocks(tex, out_tex, create_tikz=args.create_tikz)

    # ğŸ†• v1.0.1ï¼šç§»é™¤è¿ç»­é‡å¤è¡Œï¼ˆé»˜è®¤å¯ç”¨ï¼‰
    if not args.no_dedup:
        tex = remove_consecutive_duplicate_lines(tex)

    # Optionally apply a plan (search/replace style)
    plan = load_plan(Path(args.plan)) if args.plan else None
    tex = apply_plan(tex, plan)

    out_tex.write_text(tex, encoding="utf-8")

    print(f"Refined TeX written: {out_tex}")
    if created:
        print(f"Created {len(created)} tikz template(s) under {created[0].parent}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
